{"name":"Filigree","tagline":"For more beautiful Ruby","body":"Filigree: For more beautiful Ruby\r\n=================================\r\n\r\nFiligree is a collection of classes, modules, and functions that I found myself re-writing in each of my projects.  In addition, I have thrown in a couple of other features that I've always wanted.  Here are some of those features:\r\n\r\n* Abstract classes and methods\r\n* An implementation of pattern matching\r\n* An implementation of the visitor pattern\r\n* Module for defining class methods in a mixin\r\n* Modules for configuration and command handling\r\n* Easy dynamic type checking\r\n* Small extensions to standard library classes\r\n\r\nI'm going to go over some of the more important features below, but I won't be able to cover everything.  Explore the rest of the documentation to discover additional features.\r\n\r\nAbstract Classes and Methods\r\n----------------------------\r\n\r\nAbstract classes as methods can be defined as follows:\r\n\r\n```Ruby\r\nclass Foo\r\n  extend Filigree::AbstractClass\r\n\r\n  abstract_method :must_implement\r\nend\r\n\r\nclass Bar < Foo;\r\n\r\n# Raises an AbstractClassError\r\nFoo.new\r\n\r\n# Returns a new instance of Bar\r\nBar.new\r\n\r\n# Raieses an AbstractMethodError\r\nBar.new.must_implement\r\n```\r\n\r\nPattern Matching\r\n----------------\r\n\r\nFiligree provides an implementation of pattern matching.  When performing a match objects are tested against patterns defined inside the *match block*:\r\n\r\n```Ruby\r\ndef fib(n)\r\n  match n do\r\n    with(1)\r\n    with(2) { 1 }\r\n    with(_) { fib(n-1) + fib(n-2) }\r\n  end\r\nend\r\n```\r\n\r\nThe most basic pattern is the literal.  Here, the object or objects being matched will be tested for equality with the value passed to `with`.  Another simple pattern is the wildcard pattern.  It will match any value; you can think of it as the default case.\r\n\r\n```Ruby\r\n  def foo(n)\r\n    match n do\r\n      with(1) { :one   }\r\n      with(2) { :two   }\r\n      with(_) { :other }\r\n    end\r\n  end\r\n  \r\n  foo(1)  # => :one\r\n  foo(42) # => :other\r\n```\r\n\r\nYou may also match against variables.  This can sometimes conflict with the next kind of pattern, which is a binding pattern.  Here, the pattern will match any object, and then make the object it matched available to the *with block* via an attribute reader.  This is accomplished using the method_missing callback, so if there is a variable or function with that name you might accidentally compare against a variable or returned value.  To bind to a name that is already in scope you can use the {Filigree::MatchEnvironment#Bind} method.  In addition, class and destructuring pattern results (see bellow) can be bound to a variable by using the {Filigree::BasicPattern#as} method. \r\n\r\n```Ruby\r\nvar = 42\r\n\r\n# Returns :hoopy\r\nmatch 42 do\r\n  with(var) { :hoopy }\r\n  with(0)   { :zero  }\r\nend\r\n\r\n# Returns 42\r\nmatch 42 do\r\n  with(x) { x }\r\nend\r\n\r\nx = 3\r\n# Returns 42\r\nmatch 42 do\r\n  with(Bind(:x)) { x      }\r\n  with(42)       { :hoopy }\r\nend\r\n```\r\n\r\nIf you wish to match string patterns you can use regular expressions.  Any object that isn't a string will fail to match against a regular expression. If the object being matched is a string then the regular expressions `match?` method is used.  The result of the regular expression match is available inside the *with block* via the match_data accessor.\r\n\r\n```Ruby\r\ndef matcher(object)\r\n match object do\r\n   with(/hoopy/) { 42      }\r\n   with(Integer) { 'hoopy' }\r\n end\r\nend\r\n\r\nmatcher('hoopy') # => 42\r\nmatcher(42)      # => 'hoopy'\r\n```\r\n\r\nWhen a class is used in a pattern it will match any object that is an instance of that class.  If you wish to compare one regular expression to\r\nanother, or one class to another, you can force the comparison using the {Filigree::MatchEnvironment#Literal} method.\r\n\r\nDestructuring patterns allow you to match against an instance of a class, while simultaneously binding values stored inside the object to variables in the context of the *with block*.  A class that is destructurable must include the {Filigree::Destructurable} module.  You can then destructure an object like this:\r\n\r\n```Ruby\r\nclass Foo\r\n  include Filigree::Destructurable\r\n    def initialize(a, b)\r\n    @a = a\r\n    @b = b\r\n  end\r\n\r\n  def destructure(_)\r\n    [@a, @b]\r\n  end\r\nend\r\n\r\n# Returns true\r\nmatch Foo.new(4, 2) do\r\n  with(Foo.(4, 2)) { true  }\r\n  with(_)          { false }\r\nend\r\n```\r\n\r\nOf particular note is the destructuring of arrays.  When an array is destructured like so, `Array.(xs)`, the array is bound to `xs`.  If an additional pattern is added, `Array.(x, xs)`, then `x` will hold the first element of the array and `xs` will hold the remailing characters.  As more patterns are added more elements will be pulled off of the front of the array.  You can match an array with a specific number of elements by using an empty array litteral: `Array.(x, [])`\r\n\r\nBoth `match` and `with` can take multiple arguments.  When this happens, each object is paired up with the corresponding pattern.  If they all match, then the `with` clause matches.  In this way you can match against tuples.\r\n\r\nAny with clause can be given a guard clause by passing a lambda as the last argument to `with`.  These are evaluated after the pattern is matched, and any bindings made in the pattern are available to the guard clause.\r\n\r\n```Ruby\r\nmatch o do\r\n  with(n, -> { n < 0 }) { :NEG  }\r\n  with(0)               { :ZERO }\r\n  with(n, -> { n > 0 }) { :POS  }\r\nend\r\n```\r\n\r\nIf you wish to evaluate the same body on matching any of several patterns you may list them in order and then specify the body for the last pattern in the group.\r\n\r\nPatterns are evaluated in the order in which they are defined and the first pattern to match is the one chosen.  You may define helper methods inside the match block.  They will be re-defined every time the match statement is evaluated, so you should move any definitions outside any match calls that are being evaluated often.\r\n\r\nA Visitor Pattern\r\n-----------------\r\n\r\nFiligree's implementation of the visitor pattern is built on the pattern matching functionality described above.  It's usage is pretty simple:\r\n\r\n```Ruby\r\nclass Binary < Struct.new(:x, :y)\r\n  extend  Filigree::Destructurable\r\n  include Filigree::Visitor\r\n  \r\n  def destructure(_)\r\n    [x, y]\r\n  end\r\nend\r\n\r\nclass Add < Binary; end\r\nclass Mul < Binary; end\r\n\r\nclass MathVisitor\r\n  include Filigree::Visitor\r\n  \r\n  on(Add.(x, y)) do\r\n    x + y\r\n  end\r\n  \r\n  on(Mul.(x, y)) do\r\n    x * y\r\n  end\r\nend\r\n\r\nmv = MathVisitor.new\r\n\r\nmv.visit(Add.new(6, 8)) # => 14\r\nmv.visit(Mul.new(7, 6)) # => 42\r\n```\r\n\r\nClass Methods\r\n-------------\r\n\r\n{Filigree::ClassMethodsModule} makes it easy to add class methods to mixins:\r\n\r\n```Ruby\r\nmodule Foo\r\n  include Filigree::ClassMethodsModule\r\n\r\n  def foo\r\n\t  :foo\r\n  end\r\n\r\n  module ClassMethods\r\n\t  def bar\r\n\t\t  :bar\r\n\t  end\r\n  end\r\nend\r\n\r\nclass Baz\r\n  include Foo\r\nend\r\n\r\nBaz.new.foo # => :foo\r\nBa.bar      # => :bar\r\n```\r\n\r\nConfiguration Handling\r\n----------------------\r\n\r\n{Filigree::Configuration} will help you parse command line options:\r\n\r\n```Ruby\r\nclass MyConfig\r\n  include Filigree::Configuration\r\n  \r\n  add_option Filigree::Configuration::HELP_OPTION\r\n  \r\n  help 'Sets the target'\r\n  required\r\n  string_option 'target', 't'\r\n  \r\n  help 'Set the port for the target'\r\n  default 1025\r\n  option 'port', 'p', conversions: [:to_i]\r\n  \r\n  help 'Set credentials'\r\n  default ['user', 'password']\r\n  option 'credentials', 'c', conversions: [:to_s, :to_s]\r\n  \r\n  help 'Be verbose'\r\n  bool_option 'verbose', 'v'\r\n  \r\n  auto 'next_port' { self.port + 1 }\r\n  \r\n  help 'load data from file'\r\n  option 'file', 'f' do |f|\r\n    process_file f\r\n  end\r\nend\r\n\r\n# Defaults to parsing ARGV\r\nconf = MyConfig.new(['-t', 'localhost', '-v'])\r\n\r\nconf.target    # => 'localhost'\r\nconf.next_port # => 1026\r\n\r\n# You can searialize configurations to a strings, file, or IO objects\r\nserialized_config = conf.dump\r\n# And then load the configuration from the serialized version\r\nconf = MyConfig.new serialized_config\r\n```\r\n\r\nCommand Handling\r\n----------------\r\n\r\nNow that we can parse configuration options, how about we handle commands?\r\n\r\n```Ruby\r\nclass MyCommands\r\n  include Filigree::Commands\r\n  \r\n  help 'Adds two numbers together'\r\n  param 'x', 'The first number to add'\r\n  param 'y', 'The second number to add'\r\n  command 'add' do |x, y|\r\n    x.to_i + y.to_i\r\n  end\r\n  \r\n  help 'Say hello from the command handler'\r\n  config do\r\n    default 'world'\r\n    string_option 'subject', 's' \r\n  end\r\n  command 'hello' do\r\n    \"hello #{subject}\"\r\n  end\r\nend\r\n\r\nmc = MyCommands.new\r\n\r\nmc.('add 35 7')       # => 42\r\nmc.('hello')          # => 'hello world'\r\nmc.('hello -s chris') # => 'hello chris'\r\n```\r\n\r\nType Checking\r\n-------------\r\n\r\nFiligree provides two ways to perform basic type checking at run time:\r\n\r\n1. {check_type} and {check_array_type}\r\n2. {Filigree::TypedClass}\r\n\r\nThe first option will simply check the type of an object or an array of objects.  Optionally, you can assign blame to a named variable, allow the value to be nil, or perform strict checking.  Strict checking uses the `instance_of?` method while non-strict checking uses `is_a?`.\r\n\r\nThe second option works like so:\r\n\r\n```Ruby\r\nclass Foo\r\n\tinclude Filigree::TypedClass\r\n\t\r\n\ttyped_ivar :bar, Integer\r\n\ttyped_ivar :baz, String\r\n\t\r\n\tdefault_constructor\r\nend\r\n\r\nvar = Foo.new(42, '42')\r\nvar.bar = '42' # Raises a TypeError\r\n```\r\n\r\nArray#map\r\n---------\r\n\r\nThe Array class has been monkey patched so that it takes an optional symbol argument.  If it is provided, the symbol is sent to each of the objects in the array and the result is used for the new array.\r\n\r\n```Ruby\r\n[1, 2, 3, 4].map :to_sym # => [:1, :2, :3, :4]\r\n```\r\n\r\nContributing\r\n------------\r\n\r\nDo you have bits of code that you use in all of your projects but arn't big enough for theirn own gem?  Well, maybe your code could find a home in Filigree!  Send me a patch that includes the useful bits and some tests and I'll se about adding it.\r\n\r\nOther than that, what Filigree really needs is uses.  Add it to your project and let me know what features you use and which you don't; where you would like to see improvements, and what pieces you really liked.  Above all, submit issues if you encountere any bugs!\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/chriswailes/filigree/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}